---
title: R0~R16寄存器作用
date: 2021-08-09 01:05
tags: [寄存器]
categories: [计算机原理]
---

# R0~R16寄存器作用

## R0-R3    

用作传入函数参数，传出函数返回值。在子程序调用之间，可以将 r0-r3 用于任何用途。

被调用函数在返回之前不必恢复 r0-r3。如果调用函数需要再次使用 r0-r3 的内容，则它必须保留这些内容。

## R4-R10

被用来存放函数的局部变量。如果被调用函数使用了这些寄存器，它在返回之前必须恢复这些寄存器的值。

## R11- fp(frame pointer)寄存器

即可以用来记录回溯信息,也可以当做局部变量来使用

## R12-内部调用暂时寄存器 ip

它在过程链接胶合代码（例如，交互操作胶合代码）中用于此角色。
在过程调用之间，可以将它用于任何用途。被调用函数在返回之前不必恢复 r12。

## R13 -栈指针 sp

用户模式和系统模式共用一个SP，每种异常模式都有各自专用的R13寄存器（SP）。它们通常指向各模式所对应的专

用堆栈，也就是ARM处理器允许用户程序有六个不同的堆栈空间,ARM处理器中的R13被用作SP。当不使用堆栈时，R13 也可以用做通用数据寄存器.

当程序的运行进入异常模式时，可以将需要保护的寄存器放入R13所指向的堆栈，而当程序从异常模式返回时，则从对应的堆栈中恢复，采用这种方式可以保证异常发生后程序的正常执行。

## R14-链接寄存器 LR

在ARM体系结构中LR的特殊用途有两种：

一是执行子程序调用指令（BL ）时，会自动完成将当前的PC的值减去4的结果数据保存到LR寄存器。即将调用指令的下紧邻指令的地址保存到LR。返回时将lr赋给pc即可

二是当异常发生时，会自动完成将当前的PC保存到LR寄存器，返回时将lr-4赋给pc即可，因此在各种异常模式下可以根据LR的值返回到异常发生前的相应位置继续执行。

 为什么异常发生时，需要 sub lr, lr, #4 ?

是因为arm流水线,也就是执行第1条指令,第2条指令进行译码，将第3条指令从存储器中取出,那么pc当前等于pc+8

所以在异常发生时,此时lr=pc+8,但是pc+4是没有被执行的，所以异常返回时需要返回到(lr-4)地址上,执行已经译码的地址上.

(实例代码地址链接: 使用stmdb和ldmla实现中断 )

## R15-程序计数器 PC

PC总是指向当前指令的下两条指令的地址,即PC的值为当前指令的地址值加8个字节程序状态寄存器

R16-CPSR(CurrentProgram Status Register，当前程序状态寄存器)

CPSR可在任何运行模式下被访问，它包括条件标志位、中断禁止位、当前处理器模式标志位，以及其他一些相关的控制和状态位。


Tips:rax是什么

%rax 通常用于存储函数调用的返回结果，同时也用于乘法和除法指令中。


附录：

```
在编写 Linux bash shell 脚本时，经常会用到 $0、$1、$2、$#、$@、$*、$? 等参数。下面具体说明这些参数的含义。

假设执行 ./test.sh a b c 这样一个命令，则可以使用下面的参数来获取一些值：

$0
对应 ./test.sh 这个值。如果执行的是 ./work/test.sh， 则对应 ./work/test.sh 这个值，而不是只返回文件名本身的部分。
$1
会获取到 a，即 $1 对应传给脚本的第一个参数。
$2
会获取到 b，即 $2 对应传给脚本的第二个参数。
$3
会获取到 c，即 $3 对应传给脚本的第三个参数。$4、$5 等参数的含义依此类推。
$#
会获取到 3，对应传入脚本的参数个数，统计的参数不包括 $0。
$@
会获取到 "a" "b" "c"，也就是所有参数的列表，不包括 $0。
$*
也会获取到 "a" "b" "c"， 其值和 $@ 相同。但 "$*" 和 "$@" 有所不同。
"$*" 把所有参数合并成一个字符串，而 "$@" 会得到一个字符串参数数组。
$?
可以获取到执行 ./test.sh a b c 命令后的返回值。
在执行一个前台命令后，可以立即用 $? 获取到该命令的返回值。
该命令可以是系统自身的命令，可以是 shell 脚本，也可以是自定义的 bash 函数。
```

------
**这个公众号会持续更新技术方案、关注业内技术动向，关注一下成本不高，错过干货损失不小。
↓↓↓**
![](https://tva1.sinaimg.cn/large/e6c9d24egy1gzzmv1p67mj21bi0hcwgh.jpg)